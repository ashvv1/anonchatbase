import styles from '../../styles/Chat.module.css';
import { useContext, useState, useEffect, useRef } from 'react';
import Image from 'next/image';
import Head from 'next/head';
import { Auth } from "../../context/context";
import { useRouter } from 'next/router';
import { getFirestore, collection, onSnapshot, doc, query, setDoc } from "firebase/firestore";
const calcDate = require('../../calcDate');
const { Message } = require("../../models/messageModel");
import { signInAnonymously } from "firebase/auth";

const Chat = ({ chat_id }) => {

    const [textInput, setTextInput] = useState("");
    const [chatData, setChatData] = useState({});
    const [updating, setUpdating] = useState(false);

    const router = useRouter();

    const authContext = useContext(Auth);
    const db = getFirestore();
    const myId = authContext.auth.currentUser && authContext.auth.currentUser.uid;

    const inputRef = useRef(null);

    const chatWindowRef = useRef(null);

    useEffect(() => {
        if(myId && chatData)
      chatWindowRef.current.scrollTo(0, chatWindowRef.current.scrollHeight);
    });

    useEffect(() => {
        const chatRef = query(doc(db, "Chats", chat_id))
        const unsub = onSnapshot(chatRef, (doc) => {
            setChatData(doc.data())
        })
        return () => unsub;
    }, [chat_id, db]);

    useEffect(() => {
        if(myId && chatData?.subject){
            if(!chatData.recipients.includes(myId)){
                setDoc(doc(db, "Chats", chat_id), {
                    ...chatData,
                    recipients: [...chatData.recipients, myId]
                });
            }
        }
    }, [chatData, chat_id, db, myId])

    const handleBack = () => {
        router.push('/chats')
    }

    const handleMessageSubmit = async (e) => {
        e.preventDefault();
        setUpdating(prev => true);
        await setDoc(doc(db, "Chats", chat_id), {
            ...chatData,
            messages: [...chatData.messages, { sender: myId, text: textInput, timestamp: new Date() }]
        });
        setTextInput("")
        inputRef.current.value = "";
        setUpdating(prev => false);
    }

    const startSessionAndJoinChat = async () => {
        try {
            await signInAnonymously(authContext.auth)
                .then((res) => {
                      setDoc(doc(db, "Chats", chat_id), {
                        ...chatData,
                        recipients: [...chatData.recipients, res.user.uid]
                    });
                })

        } catch (err) {
            console.log(err);
        }

    }

    if (authContext.auth.currentUser && chatData) {
        return (
            <>
                <Head>
                    <title>{`Chat #${chat_id.slice(-5)}`}</title>
                    <meta name="description" content="Generated by create next app" />
                    <meta name="viewport" content="width=device-width, initial-scale=1" />
                    <link rel="icon" href="/favicon.ico" />
                </Head>
                <main className={styles.main}>
                    <div className={styles.Thread} >
                        <div onClick={() => handleBack()} className={styles.light}>Back to Chats</div>
                        <div className={styles.chatContainer}>
                            <div className={styles.chatMessages} ref={chatWindowRef}>
                                {chatData.messages && chatData.messages.length > 0 && chatData.messages.map(message => (
                                    <div key={`${message.timestamp.seconds}+${message.sender}`}
                                        className={`${styles.chatMessage} ${message.sender === myId && styles.alignRight}`}>
                                        {message.text}
                                        <div className={styles.threadMessageLabel}>
                                            <span>{message.sender === myId && ("From me @")}</span>{`${calcDate.toDateTime(message.timestamp.seconds)}`}
                                        </div>
                                    </div>
                                ))}
                            </div>
                            <div className={styles.chatInputContainer}>
                                <form onSubmit={(e) => handleMessageSubmit(e)} className={styles.chatInput}>
                                <input  placeholder="Type message..." ref={inputRef} onChange={(e) => setTextInput(e.target.value)}>
                                </input>
                                <button type="submit" id={styles.sendButton} disabled={textInput.length < 1} >
                                    SEND
                                </button>
                                </form>
                               
                            </div>
                        </div>
                    </div>
                </main>
            </>
        );
    } else {
        if(!chatData && authContext.auth.currentUser){
            alert("Chat no longer exists. Redirecting. ")
            router.push('/chats')
            return(<h1>Old Link</h1>)
            
        }else{
            return (
                <>
                    <Head>
                        <title>{`No Session`}</title>
                        <meta name="description" content="please start session" />
                        <meta name="viewport" content="width=device-width, initial-scale=1" />
                        <link rel="icon" href="/favicon.ico" />
                    </Head>
                    <main className={styles.main}>
                        <div className="loginContainer">
                            <h2>Start Session</h2>
                            <button onClick={() => startSessionAndJoinChat()}>Join Chat</button>
                        </div>
                    </main>
                </>)
        }
       
    }

};

{/*generates data every time that page is rendered, allows us to use paramater from route*/ }
export const getServerSideProps = async ({ params }) => {

    return {
        props: { chat_id: params.id },
    }
}

export default Chat;